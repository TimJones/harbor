#!/bin/sh
set -x
: ${SECRETS_DIR:="/var/run/harbor/secrets"}
: ${OVS_INTERGRATION_BRIDGE:="br-int"}

cfg_node=/etc/harbor/node.conf
cfg_network=/etc/harbor/network.conf

export OS_DOMAIN=$(crudini --get $cfg_network DEFAULT os_domain)
export NODE_ROLE=$(crudini --get $cfg_node DEFAULT role)

find $SECRETS_DIR -type f -printf "\n#%p\n" -exec bash -c "cat {} | sed  's|\\\n$||g'" \; > /etc/os-container.env

source /etc/os-container.env
. /opt/harbor/service-hosts.sh
. /opt/harbor/harbor-common.sh

export KUBELET_CMD='exec kubelet'

KUBE_STATUS_DIR="/run/harbor"
export KUBE_STATUS_FILE="${KUBE_STATUS_DIR}/kube-status"
mkdir -p ${KUBE_STATUS_DIR}

KUBE_STATUS="$(cat ${KUBE_STATUS_FILE})"
if [ -z "$KUBE_STATUS" ]; then
    echo "No status found, launching as bootrapper"
    export KUBE_STATUS="BOOTSTRAPPING"
    echo "$KUBE_STATUS" > ${KUBE_STATUS_FILE}
elif [ "$KUBE_STATUS" = "BOOTSTRAPPING" ]; then
    echo "This node is bootstrapping"
    export KUBE_STATUS="BOOTSTRAPPING"
elif [ "$KUBE_STATUS" = "BOOTSTRAPPED" ]; then
    echo "This node has been boostrapped, just prepping manifests"
    export KUBE_STATUS="INITALIZING"
fi;


cfg_node=/etc/harbor/node.conf
NODE_ROLE=$(crudini --get $cfg_node DEFAULT role)

if [ "$NODE_ROLE" = "master" ]; then
    echo "This is a master node."
    docker run --rm -v /etc/harbor:/etc/harbor:rw port/marina-password-gen:latest
    source /usr/bin/start-services
    #/opt/harbor/roles/master &>/var/log/harbor-boostrap &
else
    echo "Launching node boostrap script."
    source /usr/bin/start-services
    #/opt/harbor/roles/node &>/var/log/harbor-boostrap &
fi;

#/opt/harbor/roles/ovn

echo "Configuring Kuryr"
#/opt/harbor/scripts/config-kuryr


echo "Ensuring Required Host Assets Exist"
mkdir -p /var/run/swarm
touch /var/run/swarm/docker.sock


export NODE_HOSTNAME="$(hostname -s).${OS_DOMAIN}"
export KUBERNETES_API_SERVER="http://${KUBERNETES_SERVICE_HOST}:8080"
echo "Kubernetes Api Server: ${KUBERNETES_API_SERVER}"


check_required_vars NODE_HOSTNAME \
                    KUBERNETES_API_SERVER \
                    NETWORK_KUBE_SERVICE_IPS_SERVICE_IP_DNS_FREEIPA \
                    OS_DOMAIN \
                    NODE_ROLE \
                    OVS_INTERGRATION_BRIDGE \
                    KUBE_STATUS_FILE \
                    NODE_NETWORK_DEFAULT_IP

export KUBE_LAUNCH_PARAMS="--hostname-override=${NODE_HOSTNAME} \
              --allow-privileged=true \
              --api-servers=${KUBERNETES_API_SERVER} \
              --v=2 \
              --node-ip=${NODE_NETWORK_DEFAULT_IP} \
              --address=${NODE_NETWORK_DEFAULT_IP} \
              --enable-server \
              --containerized \
              --cluster-dns=${NETWORK_KUBE_SERVICE_IPS_SERVICE_IP_DNS_FREEIPA} \
              --cluster-domain=${OS_DOMAIN} \
              --network-plugin=cni \
              --config=/etc/kubernetes/manifests \
              --node-labels=harbor-role=$NODE_ROLE \
              --pod-infra-container-image=docker.io/port/system-pause:latest"


echo "Running Kubelet in background untill br-int appears"
kubelet ${KUBE_LAUNCH_PARAMS} &
KUBELET_PID=$!


echo "Waiting for ${OVS_INTERGRATION_BRIDGE} to exist"
until ovs-vsctl br-exists ${OVS_INTERGRATION_BRIDGE}; do
  sleep 30; echo "Waiting for ${OVS_INTERGRATION_BRIDGE}...";
done;


echo "Waiting for Node Bootstrap to complete"
export KUBE_STATUS="$(cat ${KUBE_STATUS_FILE})"
until [ "$KUBE_STATUS" = "BOOTSTRAPPED" ]; do
  echo "Waiting for Node Bootstrap to complete";
  sleep 30;
  export KUBE_STATUS="$(cat ${KUBE_STATUS_FILE})"
done;


echo "Stopping Kubelet"
kill ${KUBELET_PID}
wait ${KUBELET_PID}


echo "Dropping shell and launching Kubelet"
exec kubelet ${KUBE_LAUNCH_PARAMS}
